#!/usr/bin/env python3
"""Utility helpers for reporting the Music Blocks palette test coverage.

The legacy test suite lives inside examples/test-suite.html as a single
TurtleBlocks project export.  Updating that blob by hand is painful, so this
script focuses on **analysis**: it extracts every "text" value that ends with
"Test" or "Tests" and reports which palettes already have explicit coverage.

For now the desired palette list mirrors the plan in issue #5607.  The
checklist is split by palette and by difficulty tier (Beginner vs Advanced).

Usage
-----
python3 scripts/analyze_test_suite.py
"""

from __future__ import annotations

import argparse
import json
import re
import textwrap
from pathlib import Path
from typing import Iterable, Tuple


RE_CODE_BLOCK = re.compile(r'<div class="code">(\[\[.*?\]\])</div>', re.S)

# Keep the palette list close to the issue description so contributors can see
# progress at a glance.  Feel free to tweak/extend as new palettes appear.
TARGET_PALETTES: Tuple[Tuple[str, str], ...] = (
    ("Rhythm palette", "Beginner"),
    ("Rhythm palette", "Advanced"),
    ("Meter palette", "Beginner"),
    ("Meter palette", "Advanced"),
    ("Pitch palette", "Beginner"),
    ("Pitch palette", "Advanced"),
    ("Intervals palette", "Beginner"),
    ("Intervals palette", "Advanced"),
    ("Tone palette", "Beginner"),
    ("Tone palette", "Advanced"),
    ("Ornament palette", "Beginner"),
    ("Ornament palette", "Advanced"),
    ("Drum palette", "Beginner"),
    ("Drum palette", "Advanced"),
)


def read_block_blob(html_text: str) -> str:
    """Return the raw TurtleBlocks JSON from the exported HTML."""

    match = RE_CODE_BLOCK.search(html_text)
    if not match:
        raise SystemExit(
            "Could not find the TurtleBlocks code block inside test-suite.html"
        )
    return match.group(1)


def collect_text_values(block_blob: str) -> Iterable[str]:
    """Extract every "value" string from the TurtleBlocks JSON payload."""

    # The payload itself is valid JSON, so we leverage json.loads to avoid
    # brittle substring slicing.
    graph = json.loads(block_blob)
    for node in graph:
        if len(node) < 2:
            continue
        block_def = node[1]
        if isinstance(block_def, list):
            maybe_dict = block_def[1] if len(block_def) > 1 else None
            if isinstance(maybe_dict, dict) and "value" in maybe_dict:
                yield str(maybe_dict["value"])
        elif isinstance(block_def, dict) and "value" in block_def:
            yield str(block_def["value"])


def build_existing_test_table(values: Iterable[str]) -> Tuple[str, set[str]]:
    """Create a markdown table for all existing *Tests labels."""

    labels = sorted({v for v in values if "Test" in v})
    rows = ["| # | Label |", "| - | - |"]
    for idx, label in enumerate(labels, start=1):
        rows.append(f"| {idx} | {label} |")
    return "\n".join(rows) + "\n", set(labels)


def build_palette_checklist(existing_labels: set[str]) -> str:
    lines = []
    for palette, level in TARGET_PALETTES:
        label = f"{palette} ({level})"
        marker = "x" if label in existing_labels else " "
        lines.append(f"- [{marker}] {label}")
    return "\n".join(lines) + "\n"


def create_report(html_path: Path, output_path: Path) -> None:
    html_text = html_path.read_text(encoding="utf-8")
    block_blob = read_block_blob(html_text)
    table_markdown, existing = build_existing_test_table(
        list(collect_text_values(block_blob))
    )
    checklist = build_palette_checklist(existing)

    doc = textwrap.dedent(
        f"""\
# Music Blocks Test Suite Coverage

_Autogenerated via `scripts/analyze_test_suite.py`._

## Existing Named Tests
{table_markdown}
## Palette Checklist
The unchecked entries correspond to palettes that still need the action
blocks described in issue #5607.  When you add a new test, include a
label such as `print â†’ Rhythm palette (Beginner)` so it shows up here.

{checklist}

## Regenerating this file
```sh
python3 scripts/analyze_test_suite.py
```
The script reads `examples/test-suite.html` and updates this report so
we never lose track of existing TurtleBlocks regression tests.
"""
    ).strip() + "\n"

    output_path.write_text(doc, encoding="utf-8")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Export palette coverage info from the TurtleBlocks test suite",
    )
    parser.add_argument(
        "--html",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "examples" / "test-suite.html",
        help="Path to the TurtleBlocks HTML export (default: examples/test-suite.html)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path(__file__).resolve().parents[1]
        / "Docs"
        / "test-suite-coverage.md",
        help="Markdown destination (default: Docs/test-suite-coverage.md)",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    create_report(args.html, args.output)


if __name__ == "__main__":
    main()