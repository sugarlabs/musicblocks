"use strict";function _toConsumableArray(t){return _arrayWithoutHoles(t)||_iterableToArray(t)||_unsupportedIterableToArray(t)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(t,e){if(t){if("string"==typeof t)return _arrayLikeToArray(t,e);var r={}.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_arrayLikeToArray(t,e):void 0}}function _iterableToArray(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}function _arrayWithoutHoles(t){if(Array.isArray(t))return _arrayLikeToArray(t)}function _arrayLikeToArray(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=Array(e);r<e;r++)n[r]=t[r];return n}var ASTUtils=require("../ASTutils");global.last=jest.fn(function(t){return t[t.length-1]}),global.JSInterface={isSetter:jest.fn(),getSetterName:jest.fn(),isMethod:jest.fn(),isClampBlock:jest.fn(),getMethodName:jest.fn(function(t){return t}),isGetter:jest.fn(),getGetterName:jest.fn(function(t){return t}),methodReturns:jest.fn(),rearrangeMethodArgs:jest.fn(function(t,e){return e})},ASTUtils.JSInterface=JSInterface,describe("ASTUtils",function(){beforeEach(function(){jest.clearAllMocks()}),describe("BAREBONE_AST",function(){it("should return the barebone AST",function(){var t=ASTUtils.BAREBONE_AST;expect(t).toEqual(ASTUtils._bareboneAST)})}),describe("_getSetAST",function(){it("should return the AST for a setter statement",function(){var t="testIdentifier",e=["testArg"],r=ASTUtils._getSetAST(t,e);expect(r).toEqual({type:"ExpressionStatement",expression:{type:"AssignmentExpression",left:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"".concat(t)}},operator:"=",right:ASTUtils._getArgsAST(e)[0]}})})}),describe("_getGetAST",function(){it("should return the AST for a getter statement",function(){var t="testIdentifier",e=ASTUtils._getGetAST(t);expect(e).toEqual({type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"".concat(t)}})})}),describe("_getGetAST",function(){it("should return the AST for a getter statement",function(){var t="testIdentifier",e=ASTUtils._getGetAST(t);expect(e).toEqual({type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"".concat(t)}})})}),describe("_getIfAST",function(){it("should return the AST for an if statement",function(){var t=["testArg"],e=[["action1",["arg1"]]];JSInterface.isMethod.mockReturnValue(!0),JSInterface.isClampBlock.mockReturnValue(!1);var r=ASTUtils._getIfAST(t,e,void 0,0);expect(r).toEqual({type:"IfStatement",test:ASTUtils._getArgsAST(t)[0],consequent:{type:"BlockStatement",body:ASTUtils._getBlockAST(e,0)},alternate:null})}),it("should return the AST for an if-else statement",function(){var t=["testArg"],e=[["action1",["arg1"]]],r=[["action2",["arg2"]]];JSInterface.isMethod.mockReturnValue(!0),JSInterface.isClampBlock.mockReturnValue(!1);var n=ASTUtils._getIfAST(t,e,r,0);expect(n).toEqual({type:"IfStatement",test:ASTUtils._getArgsAST(t)[0],consequent:{type:"BlockStatement",body:ASTUtils._getBlockAST(e,0)},alternate:{type:"BlockStatement",body:ASTUtils._getBlockAST(r,0)}})})}),describe("_getForLoopAST",function(){it("should return the AST for a for-loop statement",function(){var t=["testArg"],e=["flow"],r=ASTUtils._getForLoopAST(t,e,0);expect(r).toEqual({type:"ForStatement",init:{type:"VariableDeclaration",kind:"let",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:"i0"},init:{type:"Literal",value:0}}]},test:{type:"BinaryExpression",left:{type:"Identifier",name:"i0"},right:ASTUtils._getArgsAST(t)[0],operator:"<"},update:{type:"UpdateExpression",argument:{type:"Identifier",name:"i0"},operator:"++",prefix:!1},body:{type:"BlockStatement",body:ASTUtils._getBlockAST(e,1)}})})}),describe("_getWhileLoopAST",function(){it("should return the AST for a while-loop statement",function(){var t=["testArg"],e=["flow"],r=ASTUtils._getWhileLoopAST(t,e,0);expect(r).toEqual({type:"WhileStatement",test:ASTUtils._getArgsAST(t)[0],body:{type:"BlockStatement",body:ASTUtils._getBlockAST(e,0)}})})}),describe("_getDoWhileLoopAST",function(){it("should return the AST for a do-while-loop statement",function(){var t=["testArg"],e=["flow"],r=ASTUtils._getDoWhileLoopAST(t,e,0);expect(r).toEqual({type:"DoWhileStatement",body:{type:"BlockStatement",body:ASTUtils._getBlockAST(e,0)},test:ASTUtils._getArgsAST(t)[0]})})}),describe("_getIncrementStmntAST",function(){it("should return the AST for an increment statement",function(){var t=ASTUtils._getIncrementStmntAST(["var_testIdentifier","testArg"],!0);expect(t).toEqual({type:"ExpressionStatement",expression:{type:"AssignmentExpression",left:{type:"Identifier",name:"testIdentifier"},operator:"=",right:{type:"BinaryExpression",left:{type:"Identifier",name:"testIdentifier"},right:ASTUtils._getArgsAST(["testArg"])[0],operator:"+"}}})}),it("should return the AST for a decrement statement",function(){var t=ASTUtils._getIncrementStmntAST(["var_testIdentifier","testArg"],!1);expect(t).toEqual({type:"ExpressionStatement",expression:{type:"AssignmentExpression",left:{type:"Identifier",name:"testIdentifier"},operator:"=",right:{type:"BinaryExpression",left:{type:"Identifier",name:"testIdentifier"},right:ASTUtils._getArgsAST(["testArg"])[0],operator:"-"}}})})}),describe("_getMethodDefAST",function(){it("should return the AST for a method definition",function(){var t="testMethod",e=ASTUtils._getMethodDefAST(t);expect(e).toEqual({type:"VariableDeclaration",kind:"let",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:"".concat(t)},init:{type:"ArrowFunctionExpression",params:[{type:"Identifier",name:"mouse"}],body:{type:"BlockStatement",body:[{type:"ReturnStatement",argument:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"ENDFLOW"}}}]},async:!0,expression:!1}}]})})}),describe("_getMethodCallAST",function(){it("should return the AST for a method call without function argument",function(){var t="testMethod",e=["testArg"];JSInterface.getMethodName.mockReturnValue(t);var r=ASTUtils._getMethodCallAST(t,e,{action:!1,statement:!0});expect(r).toEqual({type:"ExpressionStatement",expression:{type:"AwaitExpression",argument:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:t}},arguments:ASTUtils._getArgsAST(e)}}})}),it("should return the AST for a method call with action property",function(){var t="testMethod",e=ASTUtils._getMethodCallAST(t,["testArg"],{action:!0,statement:!0});expect(e).toEqual({type:"ExpressionStatement",expression:{type:"AwaitExpression",argument:{type:"CallExpression",callee:{type:"Identifier",name:"".concat(t)},arguments:[{type:"Identifier",name:"mouse"}]}}})}),it("should return the AST for a method call with statement property false",function(){var t="testMethod",e=["testArg"],r=ASTUtils._getMethodCallAST(t,e,{action:!1,statement:!1});expect(r).toEqual({type:"AwaitExpression",argument:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"".concat(JSInterface.getMethodName(t))}},arguments:ASTUtils._getArgsAST(JSInterface.rearrangeMethodArgs(t,e))}})})}),describe("_getArgExpAST",function(){it("should return the AST for a binary expression",function(){var t=["arg1","arg2"],e=ASTUtils._getArgExpAST("plus",t);expect(e).toEqual({type:"BinaryExpression",left:ASTUtils._getArgsAST([t[0]])[0],right:ASTUtils._getArgsAST([t[1]])[0],operator:"+"})}),it("should return the AST for a unary expression",function(){var t=["arg1"],e=ASTUtils._getArgExpAST("not",t);expect(e).toEqual({type:"UnaryExpression",operator:"!",argument:ASTUtils._getArgsAST([t[0]])[0],prefix:!0})}),it("should return the AST for a method call expression",function(){var t=["arg1"],e=ASTUtils._getArgExpAST("abs",t);expect(e).toEqual({type:"CallExpression",callee:{type:"Identifier",name:"Math.abs"},arguments:ASTUtils._getArgsAST(t)})})}),describe("_getArgsAST",function(){it("should return an empty array for undefined or null args",function(){expect(ASTUtils._getArgsAST(void 0)).toEqual([]),expect(ASTUtils._getArgsAST(null)).toEqual([])}),it("should return the AST for a literal argument",function(){var t=ASTUtils._getArgsAST(["testArg"]);expect(t).toEqual([{type:"Literal",value:"testArg"}])}),it("should return the AST for a boolean argument",function(){var t=ASTUtils._getArgsAST(["bool_true"]);expect(t).toEqual([{type:"Literal",value:!0}])}),it("should return the AST for a box argument",function(){var t=ASTUtils._getArgsAST(["box_testBox"]);expect(t).toEqual([{type:"Identifier",name:"testBox"}])}),it("should return the AST for a getter argument",function(){JSInterface.isGetter.mockReturnValue(!0),JSInterface.getGetterName.mockReturnValue("testGetter");var t=ASTUtils._getArgsAST([{0:"getter_testGetter"}]);expect(t).toEqual([ASTUtils._getGetAST("testGetter")])}),it("should return the AST for a method call argument",function(){JSInterface.isGetter.mockReturnValue(!1),JSInterface.methodReturns.mockReturnValue(!0);var t=ASTUtils._getArgsAST([{0:"testMethod",1:["testArg"]}]);expect(t).toEqual([ASTUtils._getMethodCallAST("testMethod",["testArg"],{statement:!1})])}),it("should return the AST for a method call argument with methodReturns true",function(){JSInterface.methodReturns=jest.fn().mockReturnValue(!0);var t=ASTUtils._getArgsAST([{0:"testMethod",1:["testArg"]}]);expect(t).toEqual([ASTUtils._getMethodCallAST("testMethod",["testArg"],{statement:!1})])}),it("should return the AST for a method call argument with methodReturns false",function(){JSInterface.methodReturns=jest.fn().mockReturnValue(!1);var t=ASTUtils._getArgsAST([{0:"testMethod",1:["testArg"]}]);expect(t).toEqual([ASTUtils._getArgExpAST("testMethod",["testArg"])])})}),describe("_getMethodCallClampAST",function(){it("should return the AST for a method call with function argument",function(){var t="testMethod",e=["testArg"],r=["flow"],n=ASTUtils._getMethodCallClampAST(t,e,r,0);expect(n).toEqual({type:"ExpressionStatement",expression:{type:"AwaitExpression",argument:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"".concat(JSInterface.getMethodName(t))}},arguments:[].concat(_toConsumableArray(ASTUtils._getArgsAST(JSInterface.rearrangeMethodArgs(t,e))),[{type:"ArrowFunctionExpression",params:[],body:{type:"BlockStatement",body:[].concat(_toConsumableArray(ASTUtils._getBlockAST(r,0)),[{type:"ReturnStatement",argument:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"ENDFLOW"}}}])},async:!0,expression:!1}])}}})})}),describe("_getBlockAST",function(){it("should return an empty array for undefined or null flows",function(){expect(ASTUtils._getBlockAST(void 0)).toEqual([]),expect(ASTUtils._getBlockAST(null)).toEqual([])}),it("should return the AST for an if block",function(){JSInterface.isMethod.mockReturnValue(!0),JSInterface.isClampBlock.mockReturnValue(!1);var t=ASTUtils._getBlockAST([["if",["testArg"],[["action1",["arg1"]]]]]);expect(t).toEqual([ASTUtils._getIfAST(["testArg"],[["action1",["arg1"]]],void 0,0)])}),it("should return the AST for an if-else block",function(){var t=ASTUtils._getBlockAST([["ifthenelse",["testArg"],["ifFlow"],["elseFlow"]]],0);expect(t).toEqual([ASTUtils._getIfAST(["testArg"],["ifFlow"],["elseFlow"],0)])}),it("should return the AST for a repeat block",function(){var t=ASTUtils._getBlockAST([["repeat",["testArg"],["flow"]]],0);expect(t).toEqual([ASTUtils._getForLoopAST(["testArg"],["flow"],0)])}),it("should return the AST for a while block",function(){var t=ASTUtils._getBlockAST([["while",["testArg"],["flow"]]],0);expect(t).toEqual([ASTUtils._getWhileLoopAST(["testArg"],["flow"],0)])}),it("should return the AST for an until block",function(){var t=ASTUtils._getBlockAST([["until",["testArg"],["flow"]]],0);expect(t).toEqual([ASTUtils._getDoWhileLoopAST(["testArg"],["flow"],0)])}),it("should return the AST for a break block",function(){var t=ASTUtils._getBlockAST([["break"]]);expect(t).toEqual([{type:"BreakStatement",label:null}])}),it("should return the AST for a switch block",function(){var t=ASTUtils._getBlockAST([["switch",["testArg"],["flow"]]],0);expect(t).toEqual([{type:"SwitchStatement",discriminant:ASTUtils._getArgsAST(["testArg"])[0],cases:ASTUtils._getBlockAST(["flow"],0)}])}),it("should return the AST for a case block",function(){var t=ASTUtils._getBlockAST([["case",["testArg"],["flow"]]],0);expect(t).toEqual([{type:"SwitchCase",test:ASTUtils._getArgsAST(["testArg"])[0],consequent:[].concat(_toConsumableArray(ASTUtils._getBlockAST(["flow"],0)),[{type:"BreakStatement",label:null}])}])}),it("should return the AST for an increment block",function(){var t=ASTUtils._getBlockAST([["increment",["testIdentifier","testArg"]]]);expect(t).toEqual([ASTUtils._getIncrementStmntAST(["testIdentifier","testArg"],!0)])}),it("should return the AST for an incrementOne block",function(){var t=ASTUtils._getBlockAST([["incrementOne",["testIdentifier"]]]);expect(t).toEqual([ASTUtils._getIncrementStmntAST(["testIdentifier",1],!0)])}),it("should return the AST for a decrementOne block",function(){var t=ASTUtils._getBlockAST([["decrementOne",["testIdentifier"]]]);expect(t).toEqual([ASTUtils._getIncrementStmntAST(["testIdentifier",1],!1)])}),it("should return the AST for a storein block",function(){var t=ASTUtils._getBlockAST([["storein",["testIdentifier","testArg"]]]);expect(t).toEqual([{type:"VariableDeclaration",kind:"var",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:"testIdentifier"},init:ASTUtils._getArgsAST(["testArg"])[0]}]}])}),it("should return the AST for a storein2 block",function(){var t=ASTUtils._getBlockAST([["storein2_testIdentifier",["testArg"]]]);expect(t).toEqual([{type:"VariableDeclaration",kind:"var",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:"testIdentifier"},init:ASTUtils._getArgsAST(["testArg"])[0]}]}])}),it("should return the AST for a nameddo block",function(){var t=ASTUtils._getBlockAST([["nameddo_testMethod",["testArg"]]]);expect(t).toEqual([ASTUtils._getMethodCallAST("testMethod",["testArg"],{action:!0})])})}),describe("getMethodAST",function(){it("should return the AST for a method",function(){var t="testMethod",e=["flow"],r=ASTUtils.getMethodAST(t,e);expect(r).toEqual({type:"VariableDeclaration",kind:"let",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:"".concat(t)},init:{type:"ArrowFunctionExpression",params:[{type:"Identifier",name:"mouse"}],body:{type:"BlockStatement",body:[].concat(_toConsumableArray(ASTUtils._getBlockAST(e)),[{type:"ReturnStatement",argument:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"ENDFLOW"}}}])},async:!0,expression:!1}}]})})}),describe("getMouseAST",function(){it("should return the AST for a mouse",function(){var t=["flow"],e=ASTUtils.getMouseAST(t);expect(e).toEqual({type:"ExpressionStatement",expression:{type:"NewExpression",callee:{type:"Identifier",name:"Mouse"},arguments:[{type:"ArrowFunctionExpression",params:[{type:"Identifier",name:"mouse"}],body:{type:"BlockStatement",body:[].concat(_toConsumableArray(ASTUtils._getBlockAST(t)),[{type:"ReturnStatement",argument:{type:"MemberExpression",object:{type:"Identifier",name:"mouse"},computed:!1,property:{type:"Identifier",name:"ENDMOUSE"}}}])},async:!0,expression:!1}]}})})})});